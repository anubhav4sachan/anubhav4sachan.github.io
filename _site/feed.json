{
    "version": "https://jsonfeed.org/version/1",
    "title": "Anubhav Sachan",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "Anubhav Sachan's portfolio",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "Anubhav Sachan",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "http://localhost:4000/2020/08/29/intuitive-nn",
            "title": "Intuitive Neural Networks",
            "summary": "With pretty much everything going on with neural networks, it is high time to understand the logical intuitiveness with minimal math behind them.",
            "content_text": "Machine learning is a field of study which focuses on the improvement of the performance measure through experiences for some specific tasks. With the introduction of LeNet by Prof. LeCun on the classification of handwritten digits (MNIST) dataset in late 90s, people in research community came to an understanding that neural networks with more than one hidden layers can achieve state of the art (SoTA) results (which was a thought not much appreciated by researchers back then). The modern advances in deep learning methods are facilitated due to the presence of large amount of data and computational power provided through the GPUs and hence giving rise to huge networks like GPTs (GPT-3, being most recent), ResNet, VGG etc. In this article, we will be focusing on the foundational idea of Neural Networks on which these SoTA architectures are built upon.NeuronsA brain, in general, harnesses the network of neurons to perform dozens of complex tasks efficiently. Every neuron processes signals entering from a dendrite and gives an output which is sent to the other neuron(s) and processed upon further. Hence, we can evidently state that removal of the network or even the reduction in the complexity of networks can harm its decision making process.A snapshot from MNIST Dataset.The handwritten digits, for instance, are easily interpreted by the brain to differentiate between the digits, but if we have to write a program to classify them, it would be quite an arduous task. To solve this task, we take some inspiration from these dynamically activating neurons, and formulate a way to mimic it. The whole idea of Machine Learning and Artificial Intelligence is to develop a computer program comprising of artificial neurons (because, neurons are the most powerful entities to perform complex tasks) which shall eventually outperform the capabilities of a human brain.The impulses from the sensory parts of the body reach the dendrite and if they are strong enough to create a stimulation, the axon outputs a spike. Since, biological neurons are living cells, they can modify themselves to define a stimulation threshold and hence are dynamic in nature.A biological neuron.An artificial neuron.Similarly, the artificial neuron has some inputs and each of the input () is attached to a weight () and bias () (which are learned during their training period). The weight influences the importance of particular input. They perform a computation and produce a signal, which is forwarded through an activation function (), to produce an output spike (), given that such signal from  is above the threshold value.To illustrate, let’s consider the MNIST handwritten digits. Each digit is  px in size and each pixel has a grayscale value lying in the range of [0, 1] where 0 &amp; 1 represent black and white respectively. The 2-D array is reshaped to a single dimensional array  of length 784, and each index corresponds to an input pixel (). We know that the black/dark pixels do not contribute to the curves/textures, hence they have less importance and light/white pixels exhibit quite significance in the determination of the digit (label). The relevance of a specific pixel (termed as a feature) is determined by the weights attached.Single Layer Network$$\\begin{equation}   y = f(\\sum x_i\\cdot w_i + b)   \\label{Eq:linearregression}\\end{equation}$$Eq. 1Equation 1, mathematically, describes the basic functioning of a single layer network. It also establishes its relationship with a biological neuron. Precisely, the output $y$ is a function of an affine transformation of input features, characterized by a linear transformation of features via weighted sum, combined with a translation via the added bias.The major goal of the single layer model lies in the identification of a set of weights () for corresponding input () so as to fit the data efficiently for our predicted output (). This will ensure a generalized behaviour over the dataset.Ignoring the function  for a while, we understand that$$\\begin{equation}   \\hat{y} = x_1 \\cdot w_1 + x_2 \\cdot w_2 + ... + x_d \\cdot w_d + b   \\label{eq:expandedlr}\\end{equation}$$Eq. 2where  is total number of features from a input,  are the required weights. If we collect all the features into a vector  and all our weights into another vector , the Equation 2 can be simplified using a dot product:$$\\begin{equation}   \\hat{y} = \\textbf{w}^T \\textbf{x} + b   \\label{eq:compactoned}\\end{equation}$$Eq. 3The  in Equation 3 corresponds to features of a single data point. To express  for all the inputs (in the dataset) in a  dimensional space, we introduce a design matrix  where each row corresponds to an example and every column for a particular feature.Hence, equation 3 can be rewritten for  dimensional space as:$$\\begin{equation}   \\hat{y} = \\textbf{X}\\cdot \\textbf{w} + b   \\label{eq:compactnd}\\end{equation}$$Eq. 4and the search for the best parameters weights vector  and bias  lies in the objective function (quality measure) and the procedure to update the parameters for the improvement in quality. Fun Fact : The vectorized equations (such as in Eq. \\ref{eq:compactnd}) simplify the math and make sure the code runs faster. In fact, a GPU has a lot more cores than a standard CPU (around 4000, in comparison to CPU’s 4 cores) and this allows the multi-threading processes to work efficiently, since computation in each cell of the matrix is independent of other cells.Multi-layer PerceptronAs the name suggests, we, now, have more than one layer for our deep learning neural architecture. We described about the affine transformation (linear transformation with translation) in the previous section and described how an output from a single layered network is produced. In this section, we will dive deep into multi layer perceptron.Hidden LayersThe linear models are based on a strong assumption that the a single affine transformation can map our input data to the outputs which is quite unrealistic. In addition, linearity implies monotonicity i.e. increase in the inputs eventually will either cause increase or decrease in the outputs. Let’s think about the classification of digits, the increase in intensity of a pixel doesn’t imply the increase in probability of getting a digit of higher magnitude. Hence, this assumption will surely fail in the case of image data (and of course, various other cases).We have understood that the relevance of each input feature (pixel) is more complex than expected. So, we introduce a few more fully connected (dense) layers between the inputs and output(s) which are termed as hidden layers. This architecture is referred to as Multi-layer Perceptron (MLP).Illustration of Multi-layer Perceptron with a hidden layer of 16 neurons.Taking up our classic example of MNIST Dataset, we will define a single hidden layer with 16 neurons as shown in Figure of MLP above. The figure lucidly explains the 784 input features, a hidden layer (more such fully-connected (dense) layers can be stacked, with any number of neurons), and output layer. Take a note that, neither input nor output layer is considered to be hidden.Previously, we defined the input matrix as  where  &amp;  are number of examples and features respectively. For a one-hidden-layer MLP, with  neurons (hidden units), we can define a hidden layer matrix . Since the hidden and output layers are both fully connected, we have hidden-layer weights and biases as  and  and output layer weights and biases as  and . We have chosen simple (1) for first layer (the hidden layer) and (2) for second layer (the output layer) and  is the number of classes. For our MNIST example: .Mathematically:$$\\begin{equation}   \\textbf{H} = \\textbf{X}\\cdot \\textbf{W}^{(1)} + \\textbf{b}^{(1)},    \\textbf{O} = \\textbf{H}\\cdot \\textbf{W}^{(2)} + \\textbf{b}^{(2)}   \\label{eq:hoeq}\\end{equation}$$Eq. 5which can be rewritten as$$\\begin{equation}   \\textbf{O} = (\\textbf{X}\\cdot \\textbf{W}^{(1)} + \\textbf{b}^{(1)}) \\cdot \\textbf{W}^{(2)} + \\textbf{b}^{(2)}   = \\textbf{X}\\cdot \\textbf{W}^{(1)}\\textbf{W}^{(2)} + \\textbf{b}^{(1)}\\textbf{W}^{(2)} + \\textbf{b}^{(2)}   = \\textbf{X}\\cdot \\textbf{W} + \\textbf{b}.   \\label{eq:hoopened}\\end{equation}$$Eq. 6where  and .The end result () brings us back to a linear layer which practically equivalent to Equation 1. This means stacking linear layers over one another will again establish the linear behavior and will act as if only a single layer is present.To inculcate a non-linear behaviour, each neuron in a hidden layer is subjected to an activation function , and its outputs are referred to as activations. This activation function brings in a non-linearity and facilitates the MLP architecture to not fall back into a linear model. The equation 5 can be rewritten as:The activation function () brings up the required non-linearity, and hence, causes the stack of linear layers to be non-linear. This can be brought from various activation functions as shown in the given figure.Commonly used non-linearities/activation functions ($$f$$).This addition of non-linear layers increase the number of parameters in the neural network and hence, making it quite easy for the network to map any input with its output.ConclusionWith above illustration and simple mathematics, we understood how Single Layer and Multi Layer Perceptrons function. We also looked into how GPUs facilitate the neural networks and how addition of non-linearity boosts the neural network architecture.Footnotes  is chosen (instead of an obvious choice ) due to the fact that all the features can be visualized in a dimensional space.  is, however, used to denote the count of all the examples in a dataset. AI Stack Exchange Link: How do GPUs facilitate the training of a Deep Learning Architecture? For instance, it may depend on the surrounding pixels (referred to as \\textit{context}), like in the construction of a straight line.",
            "content_html": "<p>Machine learning is a field of study which focuses on the improvement of the performance measure through experiences for some specific tasks. With the introduction of LeNet by Prof. LeCun on the classification of handwritten digits (MNIST) dataset in late 90s, people in research community came to an understanding that neural networks with more than one hidden layers can achieve state of the art (SoTA) results (which was a thought not much appreciated by researchers back then). The modern advances in deep learning methods are facilitated due to the presence of large amount of data and computational power provided through the GPUs and hence giving rise to huge networks like GPTs (GPT-3, being most recent), ResNet, VGG etc. In this article, we will be focusing on the foundational idea of Neural Networks on which these SoTA architectures are built upon.</p><h1 id=\"neurons\">Neurons</h1><p>A brain, in general, harnesses the network of neurons to perform dozens of complex tasks efficiently. Every neuron processes signals entering from a dendrite and gives an output which is sent to the other neuron(s) and processed upon further. Hence, we can evidently state that removal of the network or even the reduction in the complexity of networks can harm its decision making process.</p><center><figure><img src=\"/assets/images/mnist_snap.png\" alt=\"mnist_snap\" style=\"width: 30%;\" /><figcaption style=\"font-size: 10pt;\">A snapshot from MNIST Dataset.</figcaption></figure></center><p>The handwritten digits, for instance, are easily interpreted by the brain to differentiate between the digits, but if we have to write a program to classify them, it would be quite an arduous task. To solve this task, we take some inspiration from these dynamically activating neurons, and formulate a way to mimic it. The whole idea of Machine Learning and Artificial Intelligence is to develop a computer program comprising of artificial neurons (because, neurons are the most powerful entities to perform complex tasks) which shall eventually outperform the capabilities of a human brain.</p><p>The impulses from the sensory parts of the body reach the dendrite and if they are strong enough to create a stimulation, the axon outputs a spike. Since, biological neurons are living cells, they can modify themselves to define a stimulation threshold and hence are dynamic in nature.</p><center><figure><img src=\"/assets/images/bio_neuron.png\" alt=\"bio_neuron\" style=\"width: 60%;\" /><figcaption style=\"font-size: 10pt;\">A biological neuron.</figcaption></figure><figure><img src=\"/assets/images/artificial_neuron.png\" alt=\"artificial_neuron\" style=\"width: 70%;\" /><figcaption style=\"font-size: 10pt;\">An artificial neuron.</figcaption></figure></center><p>Similarly, the artificial neuron has some inputs and each of the input (<script type=\"math/tex\">x_i</script>) is attached to a weight (<script type=\"math/tex\">w_i</script>) and bias (<script type=\"math/tex\">b</script>) (which are learned during their training period). The weight influences the importance of particular input. They perform a computation and produce a signal, which is forwarded through an activation function (<script type=\"math/tex\">f</script>), to produce an output spike (<script type=\"math/tex\">y</script>), given that such signal from <script type=\"math/tex\">f</script> is above the threshold value.</p><p>To illustrate, let’s consider the MNIST handwritten digits. Each digit is <script type=\"math/tex\">28\\times28</script> px in size and each pixel has a grayscale value lying in the range of [0, 1] where 0 &amp; 1 represent black and white respectively. The 2-D array is reshaped to a single dimensional array <script type=\"math/tex\">x</script> of length <em>784</em>, and each index corresponds to an input pixel (<script type=\"math/tex\">x_i</script>). We know that the black/dark pixels do not contribute to the curves/textures, hence they have less importance and light/white pixels exhibit quite significance in the determination of the digit (label). The relevance of a specific pixel (termed as a feature) is determined by the weights attached.</p><h1 id=\"single-layer-network\">Single Layer Network</h1><center><figure>$$\\begin{equation}   y = f(\\sum x_i\\cdot w_i + b)   \\label{Eq:linearregression}\\end{equation}$$<figcaption style=\"font-size: 10pt;\">Eq. 1</figcaption></figure></center><p>Equation 1, mathematically, describes the basic functioning of a single layer network. It also establishes its relationship with a biological neuron. Precisely, the output $y$ is a function of an affine transformation of input features, characterized by a linear transformation of features via weighted sum, combined with a translation via the added bias.</p><p>The major goal of the single layer model lies in the identification of a set of weights (<script type=\"math/tex\">w_i</script>) for corresponding input (<script type=\"math/tex\">x_i</script>) so as to fit the data efficiently for our predicted output (<script type=\"math/tex\">\\hat{y}</script>). This will ensure a generalized behaviour over the dataset.</p><p>Ignoring the function <script type=\"math/tex\">f</script> for a while, we understand that</p><center><figure>$$\\begin{equation}   \\hat{y} = x_1 \\cdot w_1 + x_2 \\cdot w_2 + ... + x_d \\cdot w_d + b   \\label{eq:expandedlr}\\end{equation}$$<figcaption style=\"font-size: 10pt;\">Eq. 2</figcaption></figure></center><p>where <script type=\"math/tex\">d</script> is total number of features from a input<script type=\"math/tex\">{^1}</script>, <script type=\"math/tex\">w_i</script> are the required weights. If we collect all the features into a vector <script type=\"math/tex\">\\textbf{x} \\in \\mathbb{R}^d</script> and all our weights into another vector <script type=\"math/tex\">\\textbf{w} \\in \\mathbb{R}^d</script>, the Equation 2 can be simplified using a dot product:</p><center><figure>$$\\begin{equation}   \\hat{y} = \\textbf{w}^T \\textbf{x} + b   \\label{eq:compactoned}\\end{equation}$$<figcaption style=\"font-size: 10pt;\">Eq. 3</figcaption></figure></center><p>The <script type=\"math/tex\">\\textbf{x}</script> in Equation 3 corresponds to features of a single data point. To express <script type=\"math/tex\">\\textbf{x}</script> for all the inputs (in the dataset) in a <script type=\"math/tex\">\\mathbb{R}^{n \\times d}</script> dimensional space, we introduce a design matrix <script type=\"math/tex\">\\textbf{X} \\in \\mathbb{R}^{n \\times d}</script> where each row corresponds to an example and every column for a particular feature.</p><p>Hence, equation 3 can be rewritten for <script type=\"math/tex\">n \\times d</script> dimensional space as:</p><center><figure>$$\\begin{equation}   \\hat{y} = \\textbf{X}\\cdot \\textbf{w} + b   \\label{eq:compactnd}\\end{equation}$$<figcaption style=\"font-size: 10pt;\">Eq. 4</figcaption></figure></center><p>and the search for the best parameters weights vector <script type=\"math/tex\">\\textbf{w}</script> and bias <script type=\"math/tex\">b</script> lies in the objective function (quality measure) and the procedure to update the parameters for the improvement in quality.</p><p><script type=\"math/tex\">\\circ</script> Fun Fact : The vectorized equations (such as in Eq. \\ref{eq:compactnd}) simplify the math and make sure the code runs faster<script type=\"math/tex\">^2</script>. In fact, a GPU has a lot more cores than a standard CPU (around 4000, in comparison to CPU’s 4 cores) and this allows the multi-threading processes to work efficiently, since computation in each cell of the matrix is independent of other cells.</p><h1 id=\"multi-layer-perceptron\">Multi-layer Perceptron</h1><p>As the name suggests, we, now, have more than one layer for our deep learning neural architecture. We described about the affine transformation (linear transformation with translation) in the previous section and described how an output from a single layered network is produced. In this section, we will dive deep into multi layer perceptron.</p><h2 id=\"hidden-layers\">Hidden Layers</h2><p>The linear models are based on a strong assumption that the a single affine transformation can map our input data to the outputs which is quite unrealistic. In addition, linearity implies monotonicity i.e. increase in the inputs eventually will either cause increase or decrease in the outputs. Let’s think about the classification of digits, the increase in intensity of a pixel doesn’t imply the increase in probability of getting a digit of higher magnitude. Hence, this assumption will surely fail in the case of image data (and of course, various other cases).</p><p>We have understood that the relevance of each input feature (pixel) is more complex<script type=\"math/tex\">^3</script> than expected. So, we introduce a few more fully connected (dense) layers between the inputs and output(s) which are termed as hidden layers. This architecture is referred to as Multi-layer Perceptron (MLP).</p><center><figure><img src=\"/assets/images/mlp.jpeg\" alt=\"mlp\" style=\"width: 72%;\" /><figcaption style=\"font-size: 10pt;\">Illustration of Multi-layer Perceptron with a hidden layer of 16 neurons.</figcaption></figure></center><p>Taking up our classic example of MNIST Dataset, we will define a single hidden layer with 16 neurons as shown in Figure of MLP above. The figure lucidly explains the 784 input features, a hidden layer (more such fully-connected (dense) layers can be stacked, with any number of neurons), and output layer. Take a note that, neither input nor output layer is considered to be hidden.</p><p>Previously, we defined the input matrix as <script type=\"math/tex\">\\textbf{X} \\in \\mathbb{R}^{n \\times d}</script> where <script type=\"math/tex\">n</script> &amp; <script type=\"math/tex\">d</script> are number of examples and features respectively. For a one-hidden-layer MLP, with <script type=\"math/tex\">h</script> neurons (hidden units), we can define a hidden layer matrix <script type=\"math/tex\">\\textbf{H} \\in \\mathbb{R}^{n \\times h}</script>. Since the hidden and output layers are both fully connected, we have hidden-layer weights and biases as <script type=\"math/tex\">\\textbf{W}^{(1)} \\in \\mathbb{R}^{d \\times h}</script> and <script type=\"math/tex\">\\textbf{b}^{(1)} \\in \\mathbb{R}^{1 \\times h}</script> and output layer weights and biases as <script type=\"math/tex\">\\textbf{W}^{(2)} \\in \\mathbb{R}^{h \\times c}</script> and <script type=\"math/tex\">\\textbf{b}^{(2)} \\in \\mathbb{R}^{1 \\times c}</script>. We have chosen simple (1) for first layer (the hidden layer) and (2) for second layer (the output layer) and <script type=\"math/tex\">c</script> is the number of classes. For our MNIST example: <script type=\"math/tex\">n = 1, d = 784, h = 16, c = 10</script>.</p><p>Mathematically:</p><figure><center>$$\\begin{equation}   \\textbf{H} = \\textbf{X}\\cdot \\textbf{W}^{(1)} + \\textbf{b}^{(1)},    \\textbf{O} = \\textbf{H}\\cdot \\textbf{W}^{(2)} + \\textbf{b}^{(2)}   \\label{eq:hoeq}\\end{equation}$$<figcaption style=\"font-size: 10pt;\">Eq. 5</figcaption></center></figure><p>which can be rewritten as</p><figure><center>$$\\begin{equation}   \\textbf{O} = (\\textbf{X}\\cdot \\textbf{W}^{(1)} + \\textbf{b}^{(1)}) \\cdot \\textbf{W}^{(2)} + \\textbf{b}^{(2)}   = \\textbf{X}\\cdot \\textbf{W}^{(1)}\\textbf{W}^{(2)} + \\textbf{b}^{(1)}\\textbf{W}^{(2)} + \\textbf{b}^{(2)}   = \\textbf{X}\\cdot \\textbf{W} + \\textbf{b}.   \\label{eq:hoopened}\\end{equation}$$<figcaption style=\"font-size: 10pt;\">Eq. 6</figcaption></center></figure><p>where <script type=\"math/tex\">\\textbf{W} = \\textbf{W}^{(1)}\\textbf{W}^{(2)}</script> and <script type=\"math/tex\">\\textbf{b} = \\textbf{b}^{(1)}\\textbf{W}^{(2)} + \\textbf{b}^{(2)}</script>.</p><p>The end result (<script type=\"math/tex\">\\textbf{O} = \\textbf{X}\\cdot \\textbf{W} + \\textbf{b}</script>) brings us back to a linear layer which practically equivalent to Equation 1. This means stacking linear layers over one another will again establish the linear behavior and will act as if only a single layer is present.</p><p>To inculcate a non-linear behaviour, each neuron in a hidden layer is subjected to an activation function <script type=\"math/tex\">f</script>, and its outputs are referred to as activations. This activation function brings in a non-linearity and facilitates the MLP architecture to not fall back into a linear model. The equation 5 can be rewritten as:<script type=\"math/tex\">\\begin{equation}   \\textbf{H} = f(\\textbf{X}\\cdot \\textbf{W}^{(1)} + \\textbf{b}^{(1)}),    \\textbf{O} = \\textbf{H}\\cdot \\textbf{W}^{(2)} + \\textbf{b}^{(2)}   \\label{eq:hof}\\end{equation}</script></p><p>The activation function (<script type=\"math/tex\">f</script>) brings up the required non-linearity, and hence, causes the stack of linear layers to be non-linear. This can be brought from various activation functions as shown in the given figure.</p><center><figure><img src=\"/assets/images/activationfxn.jpg\" alt=\"activationfxn\" style=\"width: 75%;\" /><figcaption style=\"font-size: 10pt;\">Commonly used non-linearities/activation functions ($$f$$).</figcaption></figure></center><p>This addition of non-linear layers increase the number of parameters in the neural network and hence, making it quite easy for the network to map any input with its output.</p><h1 id=\"conclusion\">Conclusion</h1><p>With above illustration and simple mathematics, we understood how Single Layer and Multi Layer Perceptrons function. We also looked into how GPUs facilitate the neural networks and how addition of non-linearity boosts the neural network architecture.</p><h3 id=\"footnotes\">Footnotes</h3><p><script type=\"math/tex\">^1</script> <script type=\"math/tex\">d</script> is chosen (instead of an obvious choice <script type=\"math/tex\">n</script>) due to the fact that all the features can be visualized in a <script type=\"math/tex\">d-</script>dimensional space. <script type=\"math/tex\">n</script> is, however, used to denote the count of all the examples in a dataset.</p><p><script type=\"math/tex\">^2</script> <a href=\"https://ai.stackexchange.com/questions/21938/how-do-gpus-faciliate-the-training-of-a-deep-learning-architecture\">AI Stack Exchange Link: How do GPUs facilitate the training of a Deep Learning Architecture?</a></p><p><script type=\"math/tex\">^3</script> For instance, it may depend on the surrounding pixels (referred to as \\textit{context}), like in the construction of a straight line.</p>",
            "url": "http://localhost:4000/2020/08/29/intuitive-nn",
            
            
            
            "tags": ["neural-networks","deep-learning","intution"],
            
            "date_published": "2020-08-29T00:00:00+05:30",
            "date_modified": "2020-08-29T00:00:00+05:30",
            
                "author":  {
                "name": "Anubhav Sachan",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/06/03/diktnet",
            "title": "Goal-Oriented Dialog Generation with Few-Shot Training & Knowledge Transfer",
            "summary": "This article will help you develop an intuition-based understanding of Goal-Oriented Dialogue Generation in dialogue systems, with Few-Shot training and Knowledge Transfer Networks.",
            "content_text": "This article will help you develop an intuition-based understanding of Goal-Oriented Dialogue Generation in dialogue systems, with Few-Shot training and Knowledge Transfer Networks.To be specific, we’ll learn about an unsupervised discrete sentence representation learning method that can integrate with any existing encoder-decoder dialogue model, for interpretable response generation using a minimal amount of data that is not annotated.Why few-shot learning?Deep Neural Networks have proved to be successful in data-intensive applications. Usually, as shown via conventional practice, a network having numerous parameters has a greater capacity to map the data, and more training data provides the network to have a better generalization.Such neural networks, in lack of sufficient data, tend to struggle in fixing the weights and biases for the neurons. In contrast, the human brain having much more complex network architecture does not face any difficulty in adapting to new domains. Instead, it excels in learning new concepts with limited data.Few-shot learning has, therefore, been proposed to close the performance gap between a machine learner and a human learner. In the canonical setting of few-shot learning, there is a known training set and unseen testing set with disjoint categories.This unique setting of few-shot learning poses an unprecedented challenge in efficiently utilizing the prior information in the training set, which corresponds to the known information or historical information of the human learner.Hence, NLP researchers leverage the knowledge learned by the main model to improve the performance measure of the architecture on target data.A Look Inside Few-Shot Dialogue GenerationThe architecture of Task-Oriented Multi-turn Dialog System with Reinforcement Learning.Dialogue generation aims at generating human-like responses given a human-to-human dialogue history. In a conventional task-oriented dialogue system, a response (user’s raw utterance) is taken, via either spoken language understanding (SLU) module or a natural language understanding (NLU) module, and converted to a semantic frame of dialogue acts.These dialogue acts are sent to a dialogue manager which produces the system’s next action in a semantic frame in accordance with a policy using the dialogue state tracker. Then, through natural language generation (NLG), if chosen by the policy to respond, the semantic frame is transformed into human understandable utterances.The training of deep learning-based dialogue systems is hugely dependent on large amounts of data, which questions the ability of the system to perform in a real-world environment with limited data.Hence, ‘few-shot learning’ approaches to data-efficient dialogue system training is introduced for a new domain using a latent dialogue act annotation learned in an unsupervised format from a larger multi-domain data source as proposed by Zhao et al. (2018) (referred to as Latent Action Encoder-Decoder Model).Latent Action Encoder-DecoderThe development of an unsupervised neural recognition model that can discover interpretable meaning representations of utterances as a set of discrete latent variables can improve the effectiveness of a dialogue system. This is achieved with a better interpretation of the system-intentions and modelization of the high-level decision-making policy that enables useful generalization and data-efficient domain adaptation.Built upon variational autoencoders (VAEs), DI-VAE and DI-VST discover interpretable semantics via autoencoding and context predicting, respectively. The prime focus lies in learning discrete latent representations instead of dense continuous ones because of their high interpretability.Discrete Information Variational AutoencoderDiscrete Information Variational Autoencoder (DI-VAE) has been improved upon the traditional Discrete Variational Autoencoder (VAE) through a modification in their learning objective to entertain the anti-information limitation of evidence lower bound objective (ELBO).Evidence lower bound objective as an expectation over a dataset.The term KL Divergence in ELBO tries to reduce the mutual information () between latent variables () and the input data () which explains the anti-information limitation.The resolution regarding the ignorance of the latent variables during the training phase (anti-information limitation) is to maximize both the data likelihood and mutual information between latent action and input.Joint optimization of ELBO and Mutual Information solves the anti-information limitation in a standard variational autoencoder.DI-VAE maximizes the ELBO jointly with the mutual information between input data and latent actions. It minimizes the KL Divergence using Batch Prior Regularization which proves to be advantageous over, the usual, Maximum Mean Discrepancy due to its non-linear nature and fundamental difference with annealing.DI-VAE infers sentence representations by the reconstruction of the input sequence, and hence considered generative.Discrete Information Variational Skip ThoughtThe skip thought is a powerful sentence representation that captures contextual information. It uses a Recurrent Neural Network to encode a sentence and then using the resulting representation it predicts the previous and next sentences.The signals through auto encoding are enriched by extending the concept of skip thought to Discrete Information Variational Skip Thought (DI-VST) that learns sentence level distributional semantics. It uses the same recognition network as DI-VAE to output z’s posterior distribution. The learning objective, as shown, is maximized by the minimization of KL Divergence term.Learning objective for DI-VST where x_p represents previous sentence and x_n as the next sentence.Integration of DI-VAE and DI-VST with Encoder and DecodersIntegration with Encoder-Decoders at training.The role of Recognition Network  is to map a sentence to the latent variable , and the generator  defines the learning signals that will be used to train ’s representation.Notably, the recognition network  does not depend on the context . This design encourages  to capture context-independent semantics. At test time, given a context , the policy network  and encoder-decoder network  will work together to generate the next response. In short, , ,  and  are the four components of the framework.With the discrete latent variable learned by the recognition and generator network, a dialogue context encoder network encodes the context into a distributed representation. The decoder, then, generates the responses using samples from posterior. Meanwhile, policy network  is trained to predict the aggregated posterior from dialogue context  via maximum likelihood training. This model is referred to as Latent Action Encoder-Decoder (LAED).Preliminary training trains two LAED models, both DI-VAE and DI-VST. Then, at the main training stage, the hierarchical encoders of both models were trained and incorporated with Few Shot Dialogue Generation Model’s decoder to obtain an extraordinary performance.Dialogue Knowledge Transfer NetworkGoal-oriented multi-domain dialogue systems, after the n-COVID19 outbreak, are widely adopted by industries to cater to the needs of existing as well as prospective customers. The data-driven dialogue systems are in development to reduce the amount of data needed for training. This will prove to save a significant amount of computational costs for enterprises.Dialogue Knowledge Transfer Network (DiKTNet) is a generative goal-oriented dialogue model designed for few-shot learning, i.e. training only using a few in-domain dialogues. The key underlying concept of this model is transfer learning. DiKTNet makes use of the latent text representation learned from several sources ranging from large-scale general-purpose textual corpora to similar dialogues in domains different to the target one.A Hierarchical Encoder-Decoder architecture with attention-based copying model is used for few-shot dialogue generation. The main task of this model is, having been trained on all the available source data, to fine-tune on the target data to be further evaluated on the full set of target-domain dialogues. Knowledge Base Information is represented as token sequences and concatenates it to the dialogue context similarly to CopyNet setup. The copy mechanism’s implementation used for such outstanding performance of DiKTNet is the Pointer-Sentinel Mixture Model.DiKTNet achieves state-of-the-art results with two-stage training:Pre-training Stage: It involves learning of dialogue action representations to capture the dialogue structure by abstracting away from surface forms. DI-VAE and DI-VST are trained on large sources of dialogue corpora from multiple domains, like, MetaLWOz corpus, in an unsupervised way with the objectives as described above and use their discretized latent codes (for both system and user) respectively in the downstream model at the next stage of training.Transfer Learning Stage: At this stage, training for the target task begins using the few-shot dialogue generation architecture as described above. Instead of direct domain transfer, domain-general dialogue understanding is incorporated from the LAED representation trained on MetaLWOz at the previous stage. LAED captures the background top-down dialogue structure: sequences of dialogue acts in a cooperative conversation, latent dialog act-induced clustering of utterances, and the overall phrase structure of spoken utterances.DiKTNet Transfer Learning Stage (Stage II).Similar to the Few Shot Dialogue Generation, as described above, the DI-VAE is used for reconstruction of the words, and DI-VST for building the context.By transferring latent dialogue knowledge from multiple sources of varying generality, a model with superior generalization is obtained for an under-represented domain.Finally, DiKTNet is HRED augmented with both ELMo encoder and LAED representation and it is the unsupervised discrete sentence representation learning method. It has the flexibility to accommodate itself via any encoder-decoder model and does not require much data to train itself.Refrences:  [1910.01302] Data-Efficient Goal-Oriented Conversation with Dialogue Knowledge Transfer Networks  [1804.08069] Unsupervised Discrete Sentence Representation Learning for Interpretable Neural Dialog Generation  [1908.05854] Few-Shot Dialogue Generation Without Annotated Data: A Transfer Learning Approach",
            "content_html": "<p>This article will help you develop an intuition-based understanding of Goal-Oriented Dialogue Generation in dialogue systems, with Few-Shot training and Knowledge Transfer Networks.</p><p>To be specific, we’ll learn about an unsupervised discrete sentence representation learning method that can integrate with any existing encoder-decoder dialogue model, for interpretable response generation using a minimal amount of data that is not annotated.</p><h1 id=\"why-few-shot-learning\">Why few-shot learning?</h1><p>Deep Neural Networks have proved to be successful in data-intensive applications. Usually, as shown via conventional practice, a network having numerous parameters has a greater capacity to map the data, and more training data provides the network to have a better generalization.</p><p>Such neural networks, in lack of sufficient data, tend to struggle in fixing the weights and biases for the neurons. In contrast, the human brain having much more complex network architecture does not face any difficulty in adapting to new domains. Instead, it excels in learning new concepts with limited data.</p><p>Few-shot learning has, therefore, been proposed to close the performance gap between a machine learner and a human learner. In the canonical setting of few-shot learning, there is a known training set and unseen testing set with disjoint categories.</p><p>This unique setting of few-shot learning poses an unprecedented challenge in efficiently utilizing the prior information in the training set, which corresponds to the known information or historical information of the human learner.</p><p>Hence, NLP researchers leverage the knowledge learned by the main model to improve the performance measure of the architecture on target data.</p><h1 id=\"a-look-inside-few-shot-dialogue-generation\">A Look Inside Few-Shot Dialogue Generation</h1><center><figure><img src=\"/assets/images/fsdg.png\" alt=\"fsdg\" style=\"width: 110%;\" /><figcaption style=\"font-size: 10pt;\">The architecture of Task-Oriented Multi-turn Dialog System with Reinforcement Learning.</figcaption></figure></center><p>Dialogue generation aims at generating human-like responses given a human-to-human dialogue history. In a conventional task-oriented dialogue system, a response (user’s raw utterance) is taken, via either spoken language understanding (SLU) module or a natural language understanding (NLU) module, and converted to a semantic frame of dialogue acts.</p><p>These dialogue acts are sent to a dialogue manager which produces the system’s next action in a semantic frame in accordance with a policy using the dialogue state tracker. Then, through natural language generation (NLG), if chosen by the policy to respond, the semantic frame is transformed into human understandable utterances.</p><p>The training of deep learning-based dialogue systems is hugely dependent on large amounts of data, which questions the ability of the system to perform in a real-world environment with limited data.</p><p>Hence, ‘few-shot learning’ approaches to data-efficient dialogue system training is introduced for a new domain using a latent dialogue act annotation learned in an unsupervised format from a larger multi-domain data source as proposed by <a href=\"https://arxiv.org/abs/1804.08069\">Zhao et al. (2018)</a> (referred to as Latent Action Encoder-Decoder Model).</p><h1 id=\"latent-action-encoder-decoder\">Latent Action Encoder-Decoder</h1><p>The development of an unsupervised neural recognition model that can discover interpretable meaning representations of utterances as a set of discrete latent variables can improve the effectiveness of a dialogue system. This is achieved with a better interpretation of the system-intentions and modelization of the high-level decision-making policy that enables useful generalization and data-efficient domain adaptation.</p><p>Built upon variational autoencoders (VAEs), DI-VAE and DI-VST discover interpretable semantics via autoencoding and context predicting, respectively. The prime focus lies in learning discrete latent representations instead of dense continuous ones because of their high interpretability.</p><h3 id=\"discrete-information-variational-autoencoder\">Discrete Information Variational Autoencoder</h3><p>Discrete Information Variational Autoencoder (DI-VAE) has been improved upon the traditional Discrete Variational Autoencoder (VAE) through a modification in their learning objective to entertain the anti-information limitation of evidence lower bound objective (ELBO).</p><center><figure><img src=\"/assets/images/elbo.png\" alt=\"elbo\" style=\"width: 80%;\" /><figcaption style=\"font-size: 10pt;\">Evidence lower bound objective as an expectation over a dataset.</figcaption></figure></center><p>The term KL Divergence in ELBO tries to reduce the mutual information (<script type=\"math/tex\">I</script>) between latent variables (<script type=\"math/tex\">Z</script>) and the input data (<script type=\"math/tex\">X</script>) which explains the anti-information limitation.</p><p>The resolution regarding the ignorance of the latent variables during the training phase (anti-information limitation) is to maximize both the data likelihood and mutual information between latent action and input.</p><center><figure><img src=\"/assets/images/optelbo.png\" alt=\"optelbo\" style=\"width: 80%;\" /><figcaption style=\"font-size: 10pt;\">Joint optimization of ELBO and Mutual Information solves the anti-information limitation in a standard variational autoencoder.</figcaption></figure></center><p>DI-VAE maximizes the ELBO jointly with the mutual information between input data and latent actions. It minimizes the KL Divergence using Batch Prior Regularization which proves to be advantageous over, the usual, Maximum Mean Discrepancy due to its non-linear nature and fundamental difference with annealing.</p><p>DI-VAE infers sentence representations by the reconstruction of the input sequence, and hence considered generative.</p><h3 id=\"discrete-information-variational-skip-thought\">Discrete Information Variational Skip Thought</h3><p>The skip thought is a powerful sentence representation that captures contextual information. It uses a Recurrent Neural Network to encode a sentence and then using the resulting representation it predicts the previous and next sentences.</p><p>The signals through auto encoding are enriched by extending the concept of skip thought to Discrete Information Variational Skip Thought (DI-VST) that learns sentence level distributional semantics. It uses the same recognition network as DI-VAE to output z’s posterior distribution. The learning objective, as shown, is maximized by the minimization of KL Divergence term.</p><center><figure><img src=\"/assets/images/divst.png\" alt=\"divst\" style=\"width: 80%;\" /><figcaption style=\"font-size: 10pt;\">Learning objective for DI-VST where x_p represents previous sentence and x_n as the next sentence.</figcaption></figure></center><h3 id=\"integration-of-di-vae-and-di-vst-with-encoder-and-decoders\">Integration of DI-VAE and DI-VST with Encoder and Decoders</h3><center><figure><img src=\"/assets/images/integration.png\" alt=\"integration\" style=\"width: 110%;\" /><figcaption style=\"font-size: 10pt;\">Integration with Encoder-Decoders at training.</figcaption></figure></center><p>The role of Recognition Network <script type=\"math/tex\">R</script> is to map a sentence to the latent variable <script type=\"math/tex\">z</script>, and the generator <script type=\"math/tex\">G</script> defines the learning signals that will be used to train <script type=\"math/tex\">z</script>’s representation.</p><p>Notably, the recognition network <script type=\"math/tex\">R</script> does not depend on the context <script type=\"math/tex\">c</script>. This design encourages <script type=\"math/tex\">z</script> to capture context-independent semantics. At test time, given a context <script type=\"math/tex\">c</script>, the policy network <script type=\"math/tex\">\\pi</script> and encoder-decoder network <script type=\"math/tex\">F</script> will work together to generate the next response. In short, <script type=\"math/tex\">R</script>, <script type=\"math/tex\">G</script>, <script type=\"math/tex\">F</script> and <script type=\"math/tex\">\\pi</script> are the four components of the framework.</p><p>With the discrete latent variable learned by the recognition and generator network, a dialogue context encoder network encodes the context into a distributed representation. The decoder, then, generates the responses using samples from posterior. Meanwhile, policy network <script type=\"math/tex\">\\pi</script> is trained to predict the aggregated posterior from dialogue context <script type=\"math/tex\">c</script> via maximum likelihood training. This model is referred to as Latent Action Encoder-Decoder (LAED).</p><p>Preliminary training trains two LAED models, both DI-VAE and DI-VST. Then, at the main training stage, the hierarchical encoders of both models were trained and incorporated with Few Shot Dialogue Generation Model’s decoder to obtain an extraordinary performance.</p><h1 id=\"dialogue-knowledge-transfer-network\">Dialogue Knowledge Transfer Network</h1><p>Goal-oriented multi-domain dialogue systems, after the n-COVID19 outbreak, are widely adopted by industries to cater to the needs of existing as well as prospective customers. The data-driven dialogue systems are in development to reduce the amount of data needed for training. This will prove to save a significant amount of computational costs for enterprises.</p><p>Dialogue Knowledge Transfer Network (DiKTNet) is a generative goal-oriented dialogue model designed for few-shot learning, i.e. training only using a few in-domain dialogues. The key underlying concept of this model is transfer learning. DiKTNet makes use of the latent text representation learned from several sources ranging from large-scale general-purpose textual corpora to similar dialogues in domains different to the target one.</p><p>A Hierarchical Encoder-Decoder architecture with attention-based copying model is used for few-shot dialogue generation. The main task of this model is, having been trained on all the available source data, to fine-tune on the target data to be further evaluated on the full set of target-domain dialogues. Knowledge Base Information is represented as token sequences and concatenates it to the dialogue context similarly to CopyNet setup. The copy mechanism’s implementation used for such outstanding performance of DiKTNet is the Pointer-Sentinel Mixture Model.</p><p>DiKTNet achieves state-of-the-art results with two-stage training:</p><p><em>Pre-training Stage:</em> It involves learning of dialogue action representations to capture the dialogue structure by abstracting away from surface forms. DI-VAE and DI-VST are trained on large sources of dialogue corpora from multiple domains, like, MetaLWOz corpus, in an unsupervised way with the objectives as described above and use their discretized latent codes (for both system and user) respectively in the downstream model at the next stage of training.</p><p><em>Transfer Learning Stage:</em> At this stage, training for the target task begins using the few-shot dialogue generation architecture as described above. Instead of direct domain transfer, domain-general dialogue understanding is incorporated from the LAED representation trained on MetaLWOz at the previous stage. LAED captures the background top-down dialogue structure: sequences of dialogue acts in a cooperative conversation, latent dialog act-induced clustering of utterances, and the overall phrase structure of spoken utterances.</p><center><figure><img src=\"/assets/images/diktnet.png\" alt=\"diktnet\" style=\"width: 110%;\" /><figcaption style=\"font-size: 10pt;\">DiKTNet Transfer Learning Stage (Stage II).</figcaption></figure></center><p>Similar to the Few Shot Dialogue Generation, as described above, the DI-VAE is used for reconstruction of the words, and DI-VST for building the context.</p><p>By transferring latent dialogue knowledge from multiple sources of varying generality, a model with superior generalization is obtained for an under-represented domain.</p><p>Finally, DiKTNet is HRED augmented with both ELMo encoder and LAED representation and it is the unsupervised discrete sentence representation learning method. It has the flexibility to accommodate itself via any encoder-decoder model and does not require much data to train itself.</p><h4 id=\"refrences\">Refrences:</h4><ul>  <li><a href=\"https://arxiv.org/abs/1910.01302\">[1910.01302] Data-Efficient Goal-Oriented Conversation with Dialogue Knowledge Transfer Networks</a></li>  <li><a href=\"https://arxiv.org/abs/1804.08069\">[1804.08069] Unsupervised Discrete Sentence Representation Learning for Interpretable Neural Dialog Generation</a></li>  <li><a href=\"https://arxiv.org/abs/1908.05854\">[1908.05854] Few-Shot Dialogue Generation Without Annotated Data: A Transfer Learning Approach</a></li></ul>",
            "url": "http://localhost:4000/2020/06/03/diktnet",
            
            
            
            "tags": ["encoder-decoder","unsupervised","representation-learning","few-shot","transfer-learning","deep-learning","reinforcement-learning","nlp","neural-networks"],
            
            "date_published": "2020-06-03T00:00:00+05:30",
            "date_modified": "2020-06-03T00:00:00+05:30",
            
                "author":  {
                "name": "Anubhav Sachan",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}